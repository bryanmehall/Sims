{
//from dev folder run $pegjs --cache parser.peg
var symbolTable = {
	"+":"addition",
    "*":"multiplication",
    "-":"subtraction",
    "/":"division",
    "<":"lessThan",
    ">":"greaterThan",
    "==":"equal",
    "&&":"and",
    "||":"or"
}

function createString(str){
	return {
            jsPrimitive:{type:"string", value:str}
	}
}
function createBinOp(left, right, op){
	return {
            jsPrimitive:{type:"apply"},
            op1:left,
            op2:right,
            function:symbolTable[op]
    } 
}
function createTernOp(first, second, third, op){
    return {
        jsPrimitive:{type:"apply"},
        op1:first,
        op2:second,
        op3:third,
        function:op
    }
}
function createApply(arg, op){
	return {
            jsPrimitive:{type:"apply"},
            op1:arg,
            function:op
    }
}
function createFunction(name){
	return {
        	name:createString(name),
        	jsPrimitive:{type:"function"}
    }
}
function createArray(elementValues){
    var elements = elementValues.map(function(value, i){
        return {
            instanceOf:"element",
            index: createString(i), //todo: replace this indexing with an index computed at runtime by passing it in as an argument to the element --concat would need to update indexes
            elementValue:value
        }
    })
    return {
            instanceOf:"array",
            jsPrimitive:{ type:"array", value:elements}
    }
}
}
start
  = Module
  
Module 
	= declarations:(Declaration "\n"*)+ {
    	var objects = {}
        declarations.forEach(function(declaration){
            var object = declaration[0].object
            var id = declaration[0].id
        	objects[id] = object
        })
        
        return objects
    }
Declaration
	= "\n"*id:Name _ "="_ object:Object { return { object: object, id: id } }
    / BlockComment

Object "object"
	= value:New "{#{"?attributes:("\n""    "*Attribute)*"}#}"? {
    	var props = {}
    	attributes.forEach(function(attr){props[attr[2].name] = attr[2].value})
        props.instanceOf = props.hasOwnProperty('instanceOf') ? props.instanceOf : value
        var type = props.hasOwnProperty('type') ? props.type : value //override type property 
        //--get rid of this when switching type system
    	return props
    }

Attribute 
    = name:Name":"" "?value:(Expression) _ Comment? {
        return {
        	name:name,
            value:value
       }
   }
Expression "expression"
	=  Conditional / Array

Conditional "conditional"
    = condition:Or _ "?"_ then:Expression _":"_ alt:Expression {
    return createTernOp(condition, then, alt, "conditional")
    }
    / Or

Value "value"
	=  Primitive / Bool / Number / String / Get / Object / Name

Apply "function application"
	= name:Name "("arg:Expression")"{return createApply(arg, name)}

Or "or"
	= left:And _ op:"||" _ right:Or { return createBinOp(left, right, op)}
    / And
And "and"
	= left:Equal _ op:"&&" _ right:And { return createBinOp(left, right, op)}
    /Equal
Equal "equality"
	=  left:Sum _ op:("<"/">"/"==") _ right:Equal { return createBinOp(left, right, op)}
    /Sum
Sum "sum"
	= left:Product _ op:("+"/"-") _ right:Sum { return createBinOp(left, right, op)}
    /Product
Product "product"
	= left:Value _ op:("*"/"/") _ right:Product { return createBinOp(left, right, op)}
    / Not

Not "not"
    ="!"value:Not {return createApply(value, "not")}
    / Apply / Value

Name "name"
	= name:[a-zA-Z0-9]+ {return name.join("")}

New = "new "name:Name _ Comment? {return name}

Search = query:Name {
	return {
            jsPrimitive:{type:"search", "query":query}
        }
    }

////////references
Get "get"
    = root:Search? attributes:("."Name)+ {
    function buildPath(rootObject, attr){
      var getData = {
              jsPrimitive:{type:"get"},
              attribute:attr[1]
      }
      if (rootObject !== null){
      	  getData.rootObject = rootObject
      }
      return getData
    }
    return attributes.reduce(buildPath, root)
}
     
////////primitives
Number 
	= value:Float / value:Int {
        return {
            	jsPrimitive:{type:"number", value:value}
        }
    }
    
Int "int"
	= digits:[0-9]+ {
    	return parseInt(digits.join(""))
     }
Float "number"
  = left:[0-9]+ "." right:[0-9]+ {
    return parseFloat(left.join("") + "." +   right.join("")); 
    }

String "string"
     = '"'characters:[a-zA-Z0-9]*'"' {
         var value = characters.join("")
         return createString(value)
     }

ArrayElement "array element"
	= Object / Expression
    
Array "array"
    = SingleLineArray / MultilineArray
    
SingleLineArray "single line array"
    ='['_ head:ArrayElement* tail:(','_ ArrayElement)*']' {
    	var remaining = tail.map(function(expr){return expr[2]})
    	return createArray([head].concat(remaining))
    }
MultilineArray "multi line array"
    ='['"{#{\n""    "* head:ArrayElement tail:('\n' '    '*ArrayElement)*'}#}\n''    '*']'{
        var remaining = tail.map(function(expr){return expr[2]})
        return createArray([head].concat(remaining))
    }

Map "map"
    = '{'_ firstKey:ArrayElement ':'_ firstValue:ArrayElement _"}"

Bool "bool"
    = value:("true" / "false") {
    return {
        	jsPrimitive:{type:"bool", value:value==="true"}
       }
    }
Primitive "static primitive"
    ="{"type:Name"}" {return {type:type}}
//whitespace
_ = " "*

//comment
Comment "comment"
	="//"[^\n]*

BlockComment "block comment"
    ="/*" (!"*/" .)* "*/"
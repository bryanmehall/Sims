addition = new func //TODO: clean up these with inheritance
    name:"addition"
    jsRep:{addition, [op1, op2]}
    op1: addition.caller.op1.equalTo.jsRep //get rid of jsRep here and have it hard coded
    op2: addition.caller.op2.equalTo.jsRep
    result: new object //number
        name:"addResult"
        equalTo:addResult
        jsRep:addition.jsRep //applying the jsRep

subtraction = new func
    name:"subtraction"
    jsRep:{subtraction, [op1, op2]}
    op1: subtraction.caller.op1.equalTo.jsRep
    op2: subtraction.caller.op2.equalTo.jsRep
    result: new object //number
        name:"subResult"
        equalTo:subResult
        jsRep:subtraction.jsRep

multiplication = new func
    name:"multiplication"
    jsRep:{multiplication, [op1, op2]}
    op1: multiplication.caller.op1.equalTo.jsRep
    op2: multiplication.caller.op2.equalTo.jsRep
    result: new object //number
        name:"multResult"
        equalTo:multResult
        jsRep:multiplication.jsRep

division = new func
    name:"division"
    jsRep:{division, [op1, op2]}
    op1: division.caller.op1.equalTo.jsRep
    op2: division.caller.op2.equalTo.jsRep
    result: new object //number
        name:"divResult"
        equalTo:divResult
        jsRep:division.jsRep

equal = new func
    name:"equal"
    jsRep:{equal, [op1, op2]}
    op1: equal.caller.op1.equalTo.jsRep
    op2: equal.caller.op2.equalTo.jsRep
    result: new object //number
        name:"eqResult"
        equalTo:eqResult
        jsRep:equal.jsRep

lessThan = new func
    name:"lessThan"
    jsRep:{lessThan, [op1, op2]}
    op1: lessThan.caller.op1.equalTo.jsRep
    op2: lessThan.caller.op2.equalTo.jsRep
    result: new object //number
        name:"ltResult"
        equalTo:ltResult
        jsRep:lessThan.jsRep

greaterThan = new func
    name:"greaterThan"
    jsRep:{greaterThan, [op1, op2]}
    op1: greaterThan.caller.op1.equalTo.jsRep
    op2: greaterThan.caller.op2.equalTo.jsRep
    result: new object //number
        name:"gtResult"
        equalTo:gtResult
        jsRep:greaterThan.jsRep

and = new func
    name:"and"
    jsRep:{and, [op1, op2]}
    op1: and.caller.op1.equalTo.jsRep
    op2: and.caller.op2.equalTo.jsRep
    result: new object //number
        name:"andResult"
        equalTo:andResult
        jsRep:and.jsRep

or = new func
    name:"or"
    jsRep:{or, [op1, op2]}
    op1: or.caller.op1.equalTo.jsRep
    op2: or.caller.op2.equalTo.jsRep
    result: new object //number
        name:"orResult"
        equalTo:orResult
        jsRep:or.jsRep

not = new func
    name:"not"
    jsRep:{not, [op1]}
    op1: not.caller.op1.equalTo.jsRep
    result: new object //number
        name:"notResult"
        equalTo:notResult
        jsRep:not.jsRep

conditional = new object
    name: "conditional" 
    jsRep:{conditional, [op1, op2, op3]}
    op1: conditional.caller.op1.equalTo.jsRep
    op2: conditional.caller.op2.equalTo.jsRep
    op3: conditional.caller.op3.equalTo.jsRep
    result: new object //number
        name:"condResult"
        equalTo:condResult
        jsRep:conditional.jsRep //applying the jsRep

concat = new func
    name:"concat"

slice = new func
    name:"slice"
splice = new func
    name:"splice"
substring = new func
    name:"substring"
insert = new func
    name: "insert"
    op1:"insertString"
    op2:"targetString"
    op3:3
    result:substring(insert.op2, 0, insert.op3-1)+insert.op1+substring(insert.op2, insert.op3-1)

getIndex = new func
    name: "getIndex" 
    jsRep:{getIndex, [op1, op2]}
    op1: getIndex.caller.op1.equalTo.jsRep
    op2: getIndex.caller.op2.equalTo.jsRep
    result: new object //parametric polymorphism for result type
        name:"indexResult"
        equalTo:indexResult
        jsRep:getIndex.jsRep.jsRep //applying the jsRep

